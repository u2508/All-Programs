public void print_Hierarchical() { System.out.print("Hierarchical "); } public void print_Inheritance() { System.out.print("Inheritance "); } public void print_Implementation() { System.out.print("Implementation"); } } class Main { public static void main(String[] args) { // Object of Child class to access methods implemented by interfaces Child obj = new Child(); obj.print_Hierarchical(); obj.print_Inheritance(); obj.print_Implementation(); } } 5. Hybrid Inheritance: Hybrid Inheritance in Java is a combination of two or more types of inheritance. In simple terms, more than one type of inheritance is being observed in the case of Hybrid inheritance. As we know that Java doesn't support multiple inheritance with classes, similarly we can't implement hybrid inheritance that consists of multiple inheritance in Java. In the case of demonstrating multiple inheritance in Java, we must have to use interfaces for implementation purposes as we have seen in the example of multiple inheritances. For example: class C { public void display() { System.out.println("C"); } } class A extends C { public void display() { System.out.println("A"); } } class B extends C { public void display() { System.out.println("B"); } } class D extends A { public void display() { System.out.println("D"); } } class Main { public static void main(String args[]) { D obj = new D(); obj.display(); } } Encapsulation: Data Encapsulation can be defined as wrapping the code or methods(properties) and the related fields or variables together as a single unit. In object-oriented programming, we call this single unit - a class, interface, etc. We can visualize it like a medical capsule (as the name suggests, too), wherein the enclosed medicine can be compared to fields and methods of a class. The variables or fields can be accessed by methods of their class and can be hidden from the other classes using private access modifiers. One thing to note here is that data hiding and encapsulation may sound the same but different. Example of Data Encapsulation:Below is a program to calculate the perimeter of a rectangle class Perimeter { int length; int breadth; Perimeter(int length, int breadth) { this.length = length; this.breadth = breadth; } public void getPerimeter() { int perimeter = 2 * (length + breadth); System.out.println("Perimeter of Rectangle : " + perimeter); } } class Main { public static void main(String[] args) { Perimeter rectangle = new Perimeter(3, 6); rectangle.getPerimeter(); } } Data Hiding Access modifiers are used to achieve data hiding. Access modifiers are the keywords that specify the accessibility or the scope of methods, classes, fields, and other members. Difference between encapsulation and data hiding is that Encapsulation is a way of bundling data whereas Data Hiding prevents external unauthorized access to the sensitive data. The four types of access modifiers in Java are:  Public: A public modifier is accessible to everyone. It can be accessed from within the class, outside the class, within the package, and outside the package. class A { // public variables public int a; public int b; // public methods public void method_1() { // Method logic }}  Private: A private modifier can not be accessed outside the class. It provides restricted access. Example: class A { // private variables private String a; private int b; }  Protected: A protected modifier can be accessed from the classes of the same package and outside the package only through inheritance. class A { // protected variables protected String a; protected int b; } A Private Access Modifier is used for the purpose of Data Hiding. Example of Data Hiding: class Employee { // private variables private String name; private int age; private int salary; } public class Main { public static void main(String[] args) { //object of class Employee Employee newObj = new Employee(); newObj.name = "James"; System.out.println(newObj.name); } } Getter and Setter Methods: As we can't directly read and set the values of private variables/fields, Java provides us with getter and setter methods to do so. How to implement Encapsulation in Java? We need to perform two steps to achieve the purpose of Encapsulation in Java.  Use the private access modifier to declare all variables/fields of class as private.  Define public getter and setter methods to read and modify/set the values of the abovesaid fields. class Book { //private fields private String author; private String title; private int id; //public getter and setter methods for each field public String getAuthor() { return author; } public void setAuthor(String a) { this.author = a; } public String getTitle() { return title; } public void setTitle(String t) { this.title = t; } public int getId() { return id; } public void setId(int i) { this.id = i; } } public class Main { public static void main(String[] args) { Book newObj = new Book(); newObj.setAuthor("Jane Austen"); newObj.setTitle("Pride and Prejudice"); newObj.setId(775); System.out.println("Book Title: " +newObj.getTitle() +"\n" + "Book Author: " +newObj.getAuthor() + "\n" +"Book Id: " +newObj.getId() ); } } Benefits of Encapsulation java  Cleaner, more organized and less complex code.  More flexible code as can modify a unit independently without changing any other unit.  Makes the code more secure.  The code can be maintained at any point without breaking the classes that use the code. Polymorphism: Polymorphism is one of the main aspects of Object-Oriented Programming(OOP). The word polymorphism can be broken down into Poly and morphs, as “Poly” means many and “Morphs” means forms. Let us understand the definition of polymorphism by an example; a lady can have different characteristics simultaneously. She can be a mother, a daughter, or a wife, so the same lady possesses different behavior in different situations. Another example of polymorphism can be seen in carbon, as carbon can exist in many forms, i.e., diamond, graphite, coal, etc. We can say that both woman and carbon show different characteristics at the same time according to the situation. This is called polymorphism. The definition of polymorphism can be explained as performing a single task in different ways. A single interface having multiple implementations is also called polymorphism. How can polymorphism be achieved in Java? Polymorphism in Java can be achieved in two ways i.e., method overloading and method overriding. Polymorphism in Java is mainly divided into two types.  Compile-time polymorphism  Runtime polymorphism Compile-time polymorphism can be achieved by method overloading, and Runtime polymorphism can be achieved by method overriding. Runtime Polymorphism: Runtime polymorphism is also called Dynamic method dispatch. Instead of resolving the overridden method at compile-time, it is resolved at runtime. Here, an overridden child class method is called through its parent's reference. Then the method is evoked according to the type of object. In runtime, JVM figures out the object type and the method belonging to that object. Runtime polymorphism in Java occurs when we have two or more classes, and all are interrelated through inheritance. To achieve runtime polymorphism, we must build an "IS-A" relationship between classes and override a method. Method overriding If a child class has a method as its parent class, it is called method overriding. If the derived class has a specific implementation of the method that has been declared in its parent class is known as method overriding. Rules for overriding a method in Java 1. There must be inheritance between classes. 2. The method between the classes must be the same(name of the class, number, and type of arguments must be the same). // Parent class to illustrate run-time polymorphism class Parent { // creating print method void print() { System.out.println("Hi I am parent"); } } // Child class extends Parent class class Child extends Parent { // overriding print method void print() { System.out.println("Hi I am children"); } } Compile-time polymorphism: This type of polymorphism in Java is also called static polymorphism or static method dispatch. It can be achieved by method overloading. In this process, an overloaded method is resolved at compile time rather than resolving at runtime. Method overloading: Consider a class where multiple methods have the same name. It will be difficult for the compiler to distinguish between every method. To overcome this problem, we pass a different number of arguments to the method or different types of arguments to the method. In this way, we achieve method overloading. In other words, a class can have multiple methods of the same name, and each method can be differentiated either by bypassing different types of parameters or bypassing a different number of parameters. // Overload class to illustrate compile-time polymorphism class Overload { // Creating a statement method void statement(String name) { System.out.println("Hi myself " + name); } // overloading statement method void statement(String fname, String lname) { System.out.println("Hi myself " + fname + " " + lname); } } public class Main { public static void main(String[] args) { // creating instance of parent Parent obj1; obj1 = new Parent(); obj1.print(); obj1 = new Child(); obj1.print(); // creating instance of overload Overload obj2 = new Overload(); obj2.statement("Soham."); obj2.statement("Soham", "Medewar."); } } Abstraction: Abstraction in Java is a process of hiding the implementation details from the user and showing only the functionality to the user. It can be achieved by using abstract classes, methods, and interfaces. An abstract class is a class that cannot be instantiated on its own and is meant to be inherited by concrete classes. An abstract method is a method declared without an implementation. Interfaces, on the other hand, are collections of abstract methods. Abstraction is a key concept in OOP and in general as well. Think about real world objects, they are made by combining raw materials like electrons, protons, and atoms, which we don't see due to the abstraction that nature exposes to make the objects more understandable. Similarly, in computer science, abstraction is used to hide the complexities of hardware and machine code from the programmer. This is achieved by using higher-level programming languages like Java, which are easier to use than low-level languages like assembly. Abstraction in Java can be achieved using the following tools it provides :  Abstract classes  Interface Interface: An interface is a fully abstract class. It includes a group of abstract methods (methods without a body). We use the interface keyword to create an interface in Java. For example, interface Language { public void getType(); public void getVersion(); } Here,  Language is an interface.  It includes abstract methods: getType() and getVersion( Implementing an Interface Like abstract classes, we cannot create objects of interfaces. To use an interface, other classes must implement it. We use the implements keyword to implement an interface. Example 1: Java Interface interface Polygon { void getArea(int length, int breadth); } // implement the Polygon interface class Rectangle implements Polygon { // implementation of abstract method public void getArea(int length, int breadth) { System.out.println("The area of the rectangle is " + (length * breadth)); } } class Main { public static void main(String[] args) { Rectangle r1 = new Rectangle(); r1.getArea(5, 6); } } Output The area of the rectangle is 30 In the above example, we have created an interface named Polygon. The interface contains an abstract method getArea(). Here, the Rectangle class implements Polygon. And, provides the implementation of the getArea() method. Similar to classes, interfaces can extend other interfaces. The extends keyword is used for extending interfaces. For example, interface Line { // members of Line interface } // extending interface interface Polygon extends Line { // members of Polygon interface // members of Line interface } Here, the Polygon interface extends the Line interface. Now, if any class implements Polygon, it should provide implementations for all the abstract methods of both Line and Polygon. Advantages of Interface in Java Now that we know what interfaces are, let's learn about why interfaces are used in Java.  Similar to abstract classes, interfaces help us to achieve abstraction in Java. Here, we know getArea() calculates the area of polygons but the way area is calculated is different for different polygons. Hence, the implementation of getArea() is independent of one another.  Interfaces provide specifications that a class (which implements it) must follow. In our previous example, we have used getArea() as a specification inside the interface Polygon. This is like setting a rule that we should be able to get the area of every polygon. Now any class that implements the Polygon interface must provide an implementation for the getArea() method.  Interfaces are also used to achieve multiple inheritance in Java. Abstract class: Generally, an abstract class in Java is a template that stores the data members and methods that we use in a program. Abstraction in Java keeps the user from viewing complex code implementations and provides the user with necessary information. We cannot instantiate the abstract class in Java directly. Instead, we can subclass the abstract class. When we use an abstract class as a subclass, the abstract class method implementation becomes available to all of its parent classes. The important rules that we need to follow while using an abstract class in Java are as follows:  The keyword "abstract" is mandatory while declaring an abstract class in Java.  Abstract classes cannot be instantiated directly.  An abstract class must have at least one abstract method.  An abstract class includes final methods.  An abstract class may also include non-abstract methods.  An abstract class can consist of constructors and static methods. Program: // Abstract class abstract class Sunstar { abstract void printInfo(); } // Abstraction performed using extends class Employee extends Sunstar { void printInfo() { String name = "avinash"; int age = 21; float salary = 222.2F; System.out.println(name); System.out.println(age); System.out.println(salary); } } // Base class class Base { public static void main(String args[]) { Sunstar s = new Employee(); s.printInfo(); } } Difference between interface and abstract class: Interface Abstract Class Keyword used: interface Keyword used: abstract Subclasses can implement an interface Subclasses have to extend abstract class Multiple interfaces can be implemented One abstract class can be extended Supports Multiple Inheritance Cannot support Multiple Inheritance Now that the differences between an interface and abstract class are clear, let us move forward. The next part will explore the crucial advantages and disadvantages that we must consider while using an abstract class in Java Packages: A Java package is a collection of similar types of sub-packages, interfaces, and classes. In Java, there are two types of packages: built-in packages and user- defined packages. The package keyword is used in Java to create Java packages. Let’s find out why we even need packages in the first place. Say you have a laptop and a bunch of data you want to store. Data includes your favorite movies, songs, and images. So, do you store them all in a single folder or make a separate category for each one and store them in their corresponding folder? It is obvious that anyone would like to create separate folders for images, videos, songs, movies, etc. And the reason is the ease of accessibility and manageability. How does Packages in Java improve accessibility and manageability? If you had clustered everything inside a single folder, you would probably spend a lot of time finding the correct file. But, separating your files and storing them in the correct folder saves you a lot of time. This way, we’re improving accessibility. Accessibility and manageability go kind of hand in hand. Managing a file is related to how easy it’s to modify a specified file to incorporate future needs. Though management includes other factors as well, like how well the code is written, having those files in a structured format is an essential requirement. You can think of it like that – “What if we write this article in a not-so-structured format and combine everything inside a single paragraph?” You obviously will have a hard time reading it. Isn’t it? So using the same analogy in application development, but here, packages in Java provide little more than that. In simple words, packages in Java are nothing but a folder that contains related files. These files could be of type Java classes or interfaces or even sub-packages (don’t forget the storing data inside the laptop analogy). Types of Packages in Java Packages in Java can be categorised into 2 categories. 1. Built-in / predefined packages 2. User-defined packages. Built-in packages When we install Java on a personal computer or laptop, many packages are automatically installed. Each of these packages is unique and capable of handling various tasks. This eliminates the need to build everything from scratch. Here are some examples of built-in packages:  java.lang  java.io  java.util  java.applet  java.awt  java.net Let’s see how you can use an inbuilt package in your Java file. import java.lang.*; public class Example { public static void main(String[] args) { double radius = 5.0; double area = Math.PI * Math.pow(radius, 2); System.out.println("Area: " + area); String message = "Hello, World!"; int length = message.length(); System.out.println("Length: " + length); int number = 42; String binary = Integer.toBinaryString(number); System.out.println("Binary: " + binary); } } User-defined packages User-defined packages are those that developers create to incorporate different needs of applications. In simple terms, User-defined packages are those that the users define. Inside a package, you can have Java files like classes, interfaces, and a package as well (called a sub-package). Sub-package:A package defined inside a package is called a sub-package. It’s used to make the structure of the package more generic. It lets users arrange their Java files into their corresponding packages. For example, say, you have a package named cars. You’ve defined supporting Java files inside it. Extended and tagging: S.No. Extends Implements 1. By using “extends” keyword a class can inherit another class, or an interface can inherit other interfaces By using “implements” keyword a class can implement an interface 2. It is not compulsory that subclass that extends a superclass override It is compulsory that class implementing an interface has to S.No. Extends Implements all the methods in a superclass. implement all the methods of that interface. 3. Only one superclass can be extended by a class. A class can implement any number of an interface at a time 4. Any number of interfaces can be extended by interface. An interface can never implement any other interface Implements: In Java, the implements keyword is used to implement an interface. An interface is a special type of class which implements a complete abstraction and only contains abstract methods. To access the interface methods, the interface must be “implemented” by another class with the implements keyword and the methods need to be implemented in the class which is inheriting the properties of the interface. Since an interface is not having the implementation of the methods, a class can implement any number of interfaces at a time. Extends: In Java, the extends keyword is used to indicate that the class which is being defined is derived from the base class using inheritance. So basically, extends keyword is used to extend the functionality of the parent class to the subclass. In Java, multiple inheritances are not allowed due to ambiguity. Therefore, a class can extend only one class to avoid ambiguity. 